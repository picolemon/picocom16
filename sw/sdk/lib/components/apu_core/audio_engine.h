
/** Picocom16 audio engine
 * - 11k sample rate stereo i2s output.
 * - Channel playback with basic effects vol, left/right and rate.
 * 
 * Formats:
 *  - must be 11025 hz mono or stereo
 *  - ogg vorbis
 *  - 16bit PCM stereo
 */
#pragma once

#include "picocom/platform.h"
#include "platform/pico/apu/hw_apu_types.h"
#include "components/flash_store/flash_store.h"
#ifdef PICOCOM_SDL
    #include "platform/sdl2/audio/sdl_audio_driver.h" // Simulated I2S to SDL2
#else    
    #include "pico/audio_i2s.h"
    #include "pico_audio/include/pico/audio.h"    
    #include "sd_card.h"    
#endif
#ifndef PICOCOM_NATIVE_SIM    
    #include "ff.h"
#endif
#include "minivorbis.h"

#ifdef __cplusplus
extern "C" {
#endif


// Config
#define MaxChannels 32                          // Max playback channels
#define MaxAudioClips 48                        // Max loaded clips
#define AUDIO_SAMPLE_BLOCK_SAMPLE_CNT 256       // Number of sampler per block
#define AUDIO_SAMPLE_BLOCK_SAMPLE_MAX_SZ (AUDIO_SAMPLE_BLOCK_SAMPLE_CNT*sizeof(uint16_t)*2) // max 2 chann

// Fwd
struct AudioClip_t;
struct RamFile_t;


/** Ram/flash file pointer */
typedef struct RamFile_t
{
    uint32_t streamOffset;
    uint32_t sourceSz;                          // Total size
    uint8_t* sourceData; 
    bool isStreaming;                           // Circular stream buffer ( non seekable )
} RamFile_t;


/** Channel stream state */
typedef struct BaseAudioStreamState_t
{    
    struct AudioClip_t* sourceClip;               // source clip    
    enum EAudioDataSource sourceType;    
#ifndef PICOCOM_NATIVE_SIM        
    FIL* file_fp;                               // File pointer for sourceType
#endif    
    struct RamFile_t ramFp;                       // File pointer for sourceType
    ov_callbacks fpHandler;                     // io read handler (for ogg stream and re-used for pcm)
    
    // audio read buffering
    bool decodedActiveReader;                   // select decodedData for reader ( reader == true ? 0 : 1, etc )                                                        
    int16_t* nextData;                          // queue next decoded data from codec
    uint32_t nextSz;                            // next data sz

    int16_t* decodedData;                       // current decoded streaming to output
    uint32_t decodedSz;                         // Size of decoded data in samples (eg. stereo 16bit is 1 sample of 4 bytes etc )
    
    bool eof;                                   // Stream ended

    struct OggVorbis_File* vorbis;
} BaseAudioStreamState_t;


/** AudioTempBuffer
 */
typedef struct AudioTempBuffer_t
{
    bool isActive;
    uint8_t buffer[AUDIO_SAMPLE_BLOCK_SAMPLE_MAX_SZ];
} AudioTempBuffer_t;


/** Playback channel state.
 */
typedef struct AudioChannel_t
{
    struct AudioClip_t* clip;                     // Source audio data    
    struct BaseAudioStreamState_t streamState;    // Decoder stream state
    float sampleOffset;                         // Current sample offset in playback ( sub sample offsets for pitching )
    float sampleStep;                           // sampler step / pitch playback speed
    int channels;                               // num channels in stream
    float volLeft;                              // volume left
    float volRight;                             // volume right
    bool loop;                                  // Loop on eof
    uint32_t playId;                            // Client play id, incremented every play
    uint32_t updateCount;                       // Last update counter
    uint32_t errorCode;                         // Error code generated by playback engine
    uint8_t playingState;                       // Channel playing state
    uint16_t clipSeq[8];                        // Clip sequence circular buffer, triggers on clip end
    uint32_t readingClipSeq;
    uint32_t writingClipSeq;
    bool isStreaming;
    uint32_t minStreamBufferSeqCnt;              // Dont play until clipSeq buffer has enough
    uint32_t streamUnderflowCnt;    
    AudioTempBuffer_t buffers[2];
} AudioChannel_t;


/** Source audio clip data.
 */
typedef struct AudioClip_t
{
    int clipId;
    enum EAudioDataFormat dataFormat;
    enum EAudioDataSource sourceType;
    char filename[256];           // filename    

    uint8_t* ramSourceData;         // filename or ptr to ram/flash
    uint32_t sourceSz;              // Size of source ( files can be 0 and dynanimc read)
    uint8_t sourceChannels;         // channel count of source ( raw pcm )
    uint32_t arenaOffset;           // Allocation arena offset
    bool isFlash;
} AudioClip_t;


/** Audio engine state
*/
typedef struct AudioEngineState_t
{
#ifndef PICOCOM_NATIVE_SIM        
    FATFS m_Fs; 
#endif    
    uint32_t m_SampleFreq;
    struct audio_buffer_pool* m_BufferPool;
    AudioChannel_t m_Channels[MaxChannels];
    AudioClip_t m_Clips[MaxAudioClips];
    bool m_Inited;
    bool m_EnableOutput;
    struct FlashStore_t flashStore;            // Flash storage    
} AudioEngineState_t;


// audio engine api
AudioEngineState_t* audio_engine_init();
void audio_engine_deinit(AudioEngineState_t* engine);
void audio_engine_updateDataStreams(AudioEngineState_t* engine); // read next data (runs on another core )
void audio_engine_updateAudio(AudioEngineState_t* engine); // update audio render
bool audio_engine_playRaw( AudioEngineState_t* engine, uint32_t channelId, const AudioChannel_t* channelState );  // Low level play state
void audio_engine_stop( AudioEngineState_t* engine, uint32_t channelId ); // stop channel
bool audio_engine_isPlaying( AudioEngineState_t* engine, uint32_t channelId ); // is channel playing
AudioClip_t* audio_engine_getClipById( AudioEngineState_t* engine, uint8_t clipId );
int16_t* audio_engine_getPooledDecoderBlock( AudioEngineState_t* engine, AudioChannel_t* channel, int samples, int channels );
void audio_engine_putPooledDecoderBlock( AudioEngineState_t* engine, AudioChannel_t* channel, int16_t* data, int samples, int channels );
int audio_engine_stop_all_channels_for_clip_id( AudioEngineState_t* engine, uint16_t clipId );
int audio_engine_free_clip( AudioEngineState_t* engine, uint16_t clipId );
int audio_engine_reset( AudioEngineState_t* engine );
int audio_engine_create_clip_mem( AudioEngineState_t* engine, uint16_t clipId, enum EAudioDataFormat format, uint8_t sourceChannels, uint32_t memOffset, uint32_t size );     // create ram buffer 
int audio_engine_create_clip_flash( AudioEngineState_t* engine, uint16_t clipId, enum EAudioDataFormat format, uint8_t sourceChannels, uint32_t flashBaseOffset, uint32_t size ); // create flash buffer 
int audio_engine_write_clip_block( AudioEngineState_t* engine, uint8_t clipId, uint32_t offset, const uint8_t* data, uint32_t blockSize, uint8_t commitFlash );   // Write data block into buffer
int audio_engine_create_clip_embeded( AudioEngineState_t* engine, uint16_t clipId, enum EAudioDataFormat format, uint8_t sourceChannels, uint8_t* buffer, uint32_t size ); // create local buffer 
int audio_engine_queue_seq( AudioEngineState_t* engine, int32_t channelId, uint16_t clipId );   // add sequence to play queue
int audio_get_channel_clip_seq_queue_size( AudioChannel_t* channel );

#ifdef __cplusplus
}
#endif
